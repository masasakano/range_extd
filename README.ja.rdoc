
= RangeExtd - Extended Range class with exclude_begin and open-ends

== Introduction

This package contains RangeExtd class, the Extended Range class that features:

1. includes exclude_begin? (to exclude the "begin" boundary),
2. allows open-ended range to the infinity (*not* undefined ends, i.e., +nil+),
3. defines NONE and ALL constants,
4. the first self-consistent logical range structure in Ruby,
5. complete compatibility within the built-in Range.

With the introduction of the excluded status of begin, in addition
to the end as in built-in Range, and open-ended feature,
the logical completeness of the 1-dimensional range is realised.

A major pro of this library is application to logical operations of multiple ranges,
most typically Float and/or Rational.
{Rangeary}[https://rubygems.org/gems/rangeary] uses this library to
fullest to realise the conept of logical range operations. In doing
them, the concept of potentially open-ended Ranges on both
begin and end is essential.  For example, the negation
of Range +(?a..?d)+ is a pair of Ranges +(-"Infinity-Character"...3)+ and
+(?d(exclusive).."Infinity-Character")+ and its negation is back to
the original +(?a..?d)+.  Such operations are possible only with this
class +RangeExtd+ 

Rangeary: {https://rubygems.org/gems/rangeary}

The built-in Range class is very useful, and has given Ruby users
a power to make easy coding.  Yet, the lack of definition of
exclusive begin boundary is a nuisance in some cases.

Having said that, there is a definite and understandable reason;
Range in Ruby is not limited at all to Numeric (or strictly speaking,
Real numbers or their representatives).  Range with any object that has a method
of <tt>succ()</tt> is found to be useful, whereas there is no reverse method for
<tt>succ()</tt> in general.
In that sense Range is inherently not symmetric.  In addition,
some regular Range objects are continuous (like Float), while others are discrete
(like Integer or String).  That may add some confusion to the strict definition.

To add the feature of the exclusive-begin boundary is in that sense
not 100 per cent trivial.  The definition I adopt for the behaviour of
{RangeExtd} is probably not the only solution.  Personally, I am content
with it, and I think it achieves the good logical completeness within the frame.

I hope you find this package to be useful.

=== Validity of a Range

Ruby default Range is very permissive for the elements.  For example,
+(true...true)+ is a valid Range whatever it means, although its use
is highly limited because you cannot iterate over it, that is,
methods like +each+ with an associated iterator and +to_a+ would raise an Exception (+TypeError+).

With this library, the validity of a Range is strictly defined.
This library adds a few methods, most notably
{Range#valid?} and {Range#empty?}
to Range, which would take immediate effect in any of its sub-classes.

As an example, <tt>(3...3).valid?</tt>  returns false, because the element 3 is
inclusive for the begin boundary, yet exclusive for the end boundary,
which are contradictory to each other.  With this RangeExtd class,
the following two are regarded as valid ranges,

  * RangeExtd.new(3, 3, true,  true)   # => an empty range
  * RangeExtd.new(3, 3, false, false)  # => a single-point range (3..3)

However, as long as the use is closed within the built-in Range, nothing has changed,
so it is completely compatible with the standard Ruby.

=== Open-ended ranges to infinity

Ruby 2.6 and 2.7 have introduced endless and beginless Ranges.
The open-ended ranges to infinity defined in this library are
compatible with them. The difference is subtle and perhaps more
conceptual or philosophical than practical (see Section "Background"
for detail).  Fear not, though. In practical applications, they are
compatible and you do not have to be aware of them.

To express open-ended ranges defined in this library, you use either of
the two (negative and positive, or former and later) constants
defined in the class {RangeExtd::Infinity}

* {RangeExtd::Infinity::NEGATIVE}
* {RangeExtd::Infinity::POSITIVE}

They are basically the objects that generalise <tt>Float::INFINITY</tt> to
any Comparable object.  For example,

   ("a"..RangeExtd::Infinity::POSITIVE).each

gives an infinite iterator with <tt>String#succ</tt>, starting from "a"
(therefore, make sure to code so it breaks the iterator at one stage!).


=== News: Library locations and else

**IMPORTANT**: The paths for the libraries are moved up by one
directory in {RangeExtd} Ver.2 from Ver.1 in order that their
locations follow the Ruby Gems convention.

==== News: Beginless Range supported

Ruby 2.7 supports {Beginless range}[https://rubyreferences.github.io/rubychanges/2.7.html#beginless-range].

+RangeExtd+ also supports it now.
With this, there are important changes in specication.

First, {RangeExtd::NONE} has +nil+ for both {RangeExtd#begin} and
{RangeExtd#end} and both {RangeExtd#exclude_begin?} and
{RangeExtd#exclude_end?} are set to true. However, this has no
difference from +RangeExtd((nil...nil), true)+, which means a
completely different object that is close to {RangeExtd::ALL} except
for the exclusion flags.  Therefore, a significant change in the
internal algorithm is required. Although it appears the same for
users, except users are now *forced* to use the {RangeExtd#is_none?} method
to check whether an object is {RangeExtd::NONE} or not.

Second, +RangeExtd.valid?(nil..)+ now returns +true+, which used to be +false+, and it
is equal to {RangeExtd::ALL}.

For example, +"abc"[nil..]+ is a perfectly valid Ruby
expression in Ruby-2.7 and later, though it used to be invalid or even
SyntaxError in earlier versions of Ruby. Hence it would be weird if +RangeExtd+ considered it invalid.

Note that +RangeExtd.valid?(true..)+ still returns +false+.

+RangeExtd::Infinity#succ+ is now undefined, in line with Float.

==== News: Endless Range supported

Now, as of 2019 October, this fully supports {Endless Range}[https://rubyreferences.github.io/rubychanges/2.6.html#endless-range-1]
introduced in Ruby 2.6.  It is released as Version 1.* finally!

==== NOTE: Relationship with Rangesmaller

This package RangeExtd supersedes the obsolete {Rangesmaller}[https://rubygems.org/gems/rangesmaller] package and class,
with the added open-ended feature and a different interface in
creating a new instance.
{https://rubygems.org/gems/rangesmaller}


== Background

=== Endless and beginless Range

{Endless Range}[https://rubyreferences.github.io/rubychanges/2.6.html#endless-range-1] and
{Beginless Range}[https://rubyreferences.github.io/rubychanges/2.7.html#beginless-range]
were introduced in Ruby 2.6 and 2.7, respectively, released in Decembers 2018
and 2019.

Thanks to them, the default Ruby +Range+ has achieved part of the
functionalities and concept of what +RangeExtd+ provides.
However, there are still some differences, some of which are clear but
some are more obscured.

The most clear advantage of this library is the support for +exclude_begin?+ (to exclude the "begin" boundary).

As for the boundary-less Ranges, this library offers, in a word,
the abstraction of open-ended range (to the infinity).
A major conceptual difference is that Ruby's default beginless/endless +Range+
provides *undefined* boundaries, whereas +RangeExtd+ does *infinite* boundaries.

The difference is subtle but significant.
Let us take a look at some examples of the standard Ruby, particularly
Numeric, because Ruby Ranges for Numeric practically provide both
functionalities. These examples highlight the difference:

  "abcdef"[..2]   # => "abc"
  "abcdef"[..2.0] # => "abc"
  "abcdef"[(-Float::INFINITY)..2]  # raise (RangeError)
  "abcdef"[(-1)..2] # => ""
  "abcdef"[(-6)..2] # => "abc"
  "abcdef"[(-7)..2] # => nil
  (-Float::INFINITY..5).first(1) # raise: can't iterate from Float (TypeError)
  (-Float::INFINITY..5).first    # => -Infinity
  (-Float::INFINITY..5).begin    # => -Infinity
  (..5).first   # raise: cannot get the first element of beginless range (RangeError)
  (..5).begin   # => nil

The first (and second) examples use a beginless Range, where the begin
value is *undefined*. Then, String class *interpretes* the "begin value"
as 0.  By contrast, the third example raises an Exception; it is
understandable because the begin value is defined but infinitely negative.
Indeed, a negative value for the index for a String has a special
meaning as demonstrated in the 4th to 6th examples.

The last five examples are interesting. {Range#begin} simply returns
the first element. When no argument is given to {Range#first};
+(Float::INFINITY..5)+ satisfies the condition, whereas a beginless
{Range} does not and hence raises +RangeError+. By contrast,
When an argument +n+ is given to {Range#first}, an Array of
+n+ elements should be returned.  Since counting from any Float is undefined, the Range
from the negative infinity raises +TypeError+.  It makes sense?

By the way, I note that +(5..8.6).last(2)+ is valid and returns +[7, 8]+ and +(2.2..8.6).size+
is also valid, to add confusion.

Another point is, although the infinity has a clear mathematical
definition, not all Ranges accept it. Let us consider your own
subset class where each instance has only a single lower-case alphabet
character and where a Range of instances can be defined in the same
way as the String class. Then, the minimum begin value and maximum end
value the Range can have are "+a+" and "+z+", respectively. In this
case, what would the positive (or negative) infinities mean?  Perhaps,
in the strictest term, the infinities for the Range should be invalid?
Or, the positive infinity should be interpreted as the index for "+z+"
in this case, or else?

Conceptually, the former interpretation is more convenient.
Indeed, {Rangeary}[https://rubygems.org/gems/rangeary] uses
+RangeExtd+ in such a way, that is,
the negation of the Range is actively used for logical operations of
Arrays of Ranges.  However, you cannot force each application to
accept the definition.  Also, you should note that if you allow this type of
flexibility, a conceptual difference between the infinite boundary and
undefined boundary is blurred.

In summary, *undefined* boundaries are undefined by definition and
their interpretations are up to each application, whereas positive or
negative infinities may have clear definitions although more
flexible interpretations may be preferred in practical applications.

Given all these, {RangeExtd::Infinity::NEGATIVE} and {RangeExtd::Infinity::POSITIVE}
in this library behaves like +nil+, though it is possible for users to
distinguish them.


=== Behaviours of endless and beginless Range

The behavious of the standard Endless Range can be a little confusing.
In addition, it seems there is a bug(s?) for +Range#size+ ([Bug #18983]{https://bugs.ruby-lang.org/issues/18983})
or at least points that contradict a specification described in the
official doc, which adds confusion.

In the Ruby implementation, the begin and end values of a beginless and endless Ranges
are both interpreted as +nil+.  In Ruby, +nil == nill+ is true and
therefore 

  (?a..).end == (5..).end

is also +true+, whereas 

  (?a..).end == (5..Float::INFINITY).end

is +false+.  Below is a more extended set of exaples.

  num1 = (5..Float::INFINITY)
  num2 = (5..)
  num1.end != num2.end  # => true
  num1.size              # => Infinity
  num2.size              # => Infinity

  str1 = (?a..)
  str1.end != num1.end   # => true
  str1.end == num2.end   # => true (because both are nil)
  str1.size              # => nil (!)
  (..?z).size            # => Infinity

See below, too.

  (..3).to_s    => "..3"
  (3..).to_s    => "3.."
  (3..nil).to_s => "3.."
  (nil..3).to_s => "..3"

  (nil..) == (..nil)   # => true
  (nil..) != (...nil)  # => true  (because exclude_end? differ)
  "abcdef"[..nil]      # => "abcdef" (i.e., it is interpreted as (0..IntegerInfinity)
                       #    (n.b., nil.to_i==0; Integer(nil) #=> TypeError))
  "abcdef"[..?a]       # raise: no implicit conversion of String into Integer (TypeError)
  "abcdef"[0..100]     # => "abcdef"
  "abcdef"[-100..100]  # => nil

  (..nil).size   # => Float::INFINITY

  (..nil).begin  # => nil
  (..nil).first  # raise: cannot get the first element of beginless range (RangeError)
  (..nil).last   # raise: cannot get the last element of endless range (RangeError)
  (..nil).end    # => nil

  (..nil).cover? 5    # => true
  (..nil).cover? ?a   # => true
  (..nil).cover? [?a] # => true
  (..nil).cover? nil  # => true

For Integer,

  num1 = (5..Float::INFINITY)
  num2 = (5..)
  num1.end != num2.end  # => true (because (Float::INFINITY != nil))
  num1.size              # => Float::INFINITY
  num2.size              # => Float::INFINITY

  (3...) == (3...nil)    # => true
  (3..)  != (3...nil)    # => true  (because exclude_end? differ)

  (3..).size   # => Float::INFINITY
  (..3).begin  # => nil
  (..3).first  # raise: cannot get the first element of beginless range (RangeError)
  (3..).last   # raise: cannot get the last element of endless range (RangeError)
  (3..).end    # => nil
  (..3).each{} # raise: `each': can't iterate from NilClass (TypeError)
  (..3).to_a   # raise: `each': can't iterate from NilClass (TypeError)
  (3..).to_a   # raise: `to_a': cannot convert endless range to an array (RangeError)
  (3..Float::INFINITY).to_a  # Infinite loop!

  (-Float::INFINITY..4).first    # => -Float::INFINITY
  (4..Float::INFINITY).last      # =>  Float::INFINITY
  (-Float::INFINITY..4).first(2) # raise: can't iterate from Float (TypeError)
  (4..Float::INFINITY).last(2)   # Infinite loop!

For String (or any user-defind class?),

  (?a..).end   == (5..).end   # => true (because both are nil)
  (?a..).end   != (5..Float::INFINITY).end      # => true
  (..?a).begin == (..5).begin # => true (because both are nil)
  (..?a).begin != ((-Float::INFINITY)..5).begin # => true
  (..?a).size  # => Float::INFINITY
  (?a..).size  # => nil

  (..?a).begin  # => nil
  (..?a).first  # raise: cannot get the first element of beginless range (RangeError)
  (?a..).last   # raise: cannot get the last element of endless range (RangeError)
  (?a..).end    # => nil
  (..?a).each{} # raise: `each': can't iterate from NilClass (TypeError)
  (..?a).to_a   # raise: `each': can't iterate from NilClass (TypeError)
  (?a..).to_a   # raise: `to_a': cannot convert endless range to an array (RangeError)
  (?a..Float::INFINITY).to_a  # raise: bad value for range (ArgumentError)  # b/c it is not String!

=== Comment about Range#size

The behaviour of +Range#size+ is highly confusing.
According to {Official doc}[https://ruby-doc.org/core-3.1.2/Range.html#method-i-size],

  Returns the count of elements in self if both begin and end values are numeric; otherwise, returns nil

But actualy Ruby does not necessarily behaves in this way. In
addition, the meaning of "elements" for general Numeric is
ambiguous. The following demonstrates it.

  (5.quo(3)...5).size      # => 3
  (5.quo(3).to_f...5).size # => 4
  (5.quo(3)..5).size       # => 4
  (5.quo(3).to_f..5).size  # => 4

== Install

  gem install range_extd

Two files

  range_extd.rb
  range_extd/infinity.rb

should be installed in one of your <tt>$LOAD_PATH</tt> 

Alternatively get it from {http://rubygems.org/gems/range_extd}

Or, if you manually install it, place all the Ruby files under +lib/+
directory under one of your +RUBYLIB+ directory paths, preserving the
directory structure. Note that +range_extd.rb+ must be directly under
the library directory.

Then all you need to do is

  require "range_extd/load_all"

Or, if you only want minimum functions of this library, you can instead

  require "range_extd/range_extd"

Basically, "+range_extd/load_all.rb+" is a wrapper Ruby file, which requires the following files:

  require "range_extd/range_extd"
  require "range_extd/nil_class"
  require "range_extd/numeric"
  require "range_extd/object"
  require "range_extd/infinity"
  require "range_extd/nowhere"
  require "range_extd/range"

Among these, the first four files are independent, whereas the last
three files are inseparatable from the first one and are automatically
require-d from the first one.

The second to fourth files are a set of utility libraries; if your code
requires them, some methods are added or some existing methods are slightly altered in the
existing Ruby built-in classes: +Object+, +NilClass+, and +Numeric+
(including +Float+ and +Integer+).
How they are modified are basically backward-compatible and simply a few
new features are added.  Their use is highly recommended; otherwise,
the use of this library would be very limited.  For example,
the compare operator +<=>+ would not be commutative without them,
which might result in some nasty surprises.  For detail, refer to the
individual references.

Have fun!


== Simple Examples

In the following, I assume all the files are required.

=== How to create a RangeExtd instance

Here are some simple examples.

   require "range_extd/load_all"
   r = RangeExtd(?a...?d, true)  # => a<...d
   r.exclude_begin?              # => true 
   r.to_a                        # => ["b", "c"]
   RangeExtd(1...2)            == (1...2)          # => true
   RangeExtd(1, 2, false, true)== (1...2)          # => true
   RangeExtd(1, 1, false, false)==(1..1)           # => true
   RangeExtd(1, 1, true, true) == RangeExtd::NONE  # => true
   RangeExtd(1, 1, false, true)  # => ArgumentError
   (RangeExtd::Infinity::NEGATIVE..RangeExtd::Infinity::POSITIVE) \
    == RangeExtd::ALL  # => true

+RangeExtd+ provides three forms for initialisation (hint: the first
form is probably the handiest with least typing and is the easiest to remember):

   RangeExtd(range, [exclude_begin=false, [exclude_end=false]])
   RangeExtd(obj_begin, obj_end, [exclude_begin=false, [exclude_end=false]])
   RangeExtd(obj_begin, string_form, obj_end, [exclude_begin=false, [exclude_end=false]])

The two parameters in the square-brackets specify the respective boundaries to be excluded if true,
or included if false (Default).  If they contradict the first
parameter of the range (+Range+ or +RangeExtd+), the latter two parameters have priorities.
Alternatively, you can specify the same parameters as the options <tt>:exclude_begin</tt>
and <tt>:exclude_end</tt>, which have the highest priorit if specified.
The <tt>string_form</tt> in the third form is like ".." (including both ends) and "<..." (excluding both ends),
set by users (see {RangeExtd.middle_strings=}() for detail), and is arguably
the most visibly-recognisable way to specify any range with <tt>exclude_begin=true</tt>.

<tt>RangeExtd.new()</tt> is the same thing.
For more detail and examples, see {RangeExtd.initialize}.


=== Slightly more advanced uses

   RangeExtd((0..), true).each do |i|
     print i
     break if i >= 9
   end    # => self;  "123456789" => STDOUT
   (nil..nil).valid?  # => true
   (1...1).valid?     # => false
   (1...1).null?      # => true
   RangeExtd.valid?(1...1)              # => false
   RangeExtd(1, 1, true, true).valid?   # => true
   RangeExtd(1, 1, true, true).empty?   # => true
   RangeExtd(?a, ?b, true, true).to_a?  # => []
   RangeExtd(?a, ?b, true, true).empty? # => true
   RangeExtd(?a, ?e, true, true).to_a?  # => ["b", "c", "d"]
   RangeExtd(?a, ?e, true, true).empty? # => false
   RangeExtd::NONE.is_none?             # => true
   RangeExtd(1...1, true) == RangeExtd::NONE # => true
   RangeExtd::ALL.is_all?               # => true
   (nil..nil).is_all?                   # => false
   (-Float::INFINITY..Float::INFINITY).is_all?    # => false
   (nil..nil).equiv_all?                # => true
   (-Float::INFINITY..Float::INFINITY).equiv_all? # => true
   (3...7).equiv?(3..6)    # => true
   (nil..nil).equiv?(RangeExtd::ALL)    # => true

All the methods that are in the built-in Range can be used.


== Description

Once the file +range_extd/range_extd.rb+ is required, the three classes are defined:

* RangeExtd
* RangeExtd::Infinity
* RangeExtd::Nowhere

Also, several methods are added or altered in Range class.
All the changes made in Range are backward-compatible with the original.

=== RangeExtd::Infinity Class

Class {RangeExtd::Infinity} has basically only two constant instances.

* RangeExtd::Infinity::NEGATIVE
* RangeExtd::Infinity::POSITIVE

They are the objects that generalise the concept of
<tt>Float::INFINITY</tt> 
to any Comparable objects.  The methods <tt><=></tt> are defined.

You can use them in the same way as other objects, such as,

  (RangeExtd::Infinity::NEGATIVE.."k")

However, since they do not have any other methods,
the use of them out of Range or its sub-classes is probably meaningless.

Note for any Numeric object, you probably would like to use <tt>Float::INFINITY</tt> instead in principle.

Any objects in any user-defined Comparable class are commutatively comparable with
those two constants, as long as the cmp method of the class is written
in the *standard* way, that is, delegating the cmp method to the
parent class, ultimately +Object+, when they encounter an object of a
class they don't know.

For more detail, see the document at {RubyGems webpage}[http://rubygems.org/gems/range_extd],
which is generated from the source-code annotation with YARD.

=== RangeExtd Class

RangeExtd objects are immutable, the same as Range.
Hence once an instance has been created, it would not change.

How to create an instance is explained above (in the Examples
sections).  Any attempt to try to create an instance of {RangeExtd} that is not
"valid" as a range (see below) raises an exception (<tt>ArgumentError</tt>), and fails.

There are two constants defined in this class:

* RangeExtd::NONE
* RangeExtd::ALL

The former represents the empty range and the latter does the range
that covers everything, namely open-ended for the both negative and
positive directions.

In addition to all the standard methods of {Range}, the following
methods are added to both {RangeExtd} and {Range} classes.
See the document of each method for detail (some are defined only in
{Range} class, as {RangeExtd} inherits it).

* <tt>exclude_begin?</tt> (not defined in {Range} class)
* <tt>valid?</tt> 
* <tt>empty?</tt> 
* <tt>null?</tt> 
* <tt>is_none?</tt> 
* <tt>is_all?</tt> 
* <tt>equiv?</tt> 

There are three class methods, the first of which is equivalent 
to the instance method <tt>valid?</tt>:

* <tt>RangeExtd.valid?</tt> 
* <tt>RangeExtd.middle_strings=(ary)</tt> 
* <tt>RangeExtd.middle_strings</tt> 

==== Details about validity, emptiness, and nullness

What is valid (<tt>#valid?</tt> => true) as a range is defined as follows.

1. Both <tt>begin</tt> and <tt>end</tt> elements must be Comparable to each other,
   and the comparison results must be consistent between the two.
   The three exceptions are {RangeExtd::NONE} and Beginless and Endless Ranges
   (introduced in Ruby 2.7 and 2.6, respectively),
   which are all valid.  Accordingly, +(nil..nil)+ is
   valid in {RangeExtd} Ver.1.0+ (nb., it used to raise Exception in Ruby 1.8).
2. Except for {RangeExtd::NONE} and Beginless Range, +Range#begin+ must have the method +<=+.
   Therefore, some Endless Ranges (Ruby 2.6 and later) like +(true..)+ are *not* valid.
   Note even "+true+" has the method +<=>+ and hence checking +<=+ is essential.
3. Similarly, except for {RangeExtd::NONE} and Endless Range, +end+ must have the method +<=+.
   Therefore, some Beginless Ranges (Ruby 2.7 and later) like +(..true)+ are *not* valid.
4. *begin* must be smaller than or equal (<tt>==</tt>) to *end*,
   that is, <tt>(begin <=> end)</tt> must be either -1 or 0.
3. If *begin* is equal to *end*, namely, <tt>(begin <=> end) == 0</tt>,
   the exclude status of the both ends must agree, except for the cases
   where both +begin+ and +end+ ani +nil+ (beginless and endless Range).
   In other words, if the +begin+ is excluded, +end+ must be also excluded,
   and vice versa.
   For example, +(1...1)+ is NOT valid for this reason,
   because any built-in Range object has the exclude status
   of +false+ (namely, inclusive) for +begin+, whereas
   +RangeExtd(1...1, true)+ is valid and equal (+==+) to {RangeExtd::NONE}.

For more detail and examples see the documents of
{RangeExtd.valid?} and {Range#valid?} 

The definition of what is empty (<tt>#empty?</tt> => true) as a range is as follows;

1. the range must be valid: <tt>valid?</tt> => true
2. if the range id discrete, that is, +begin+ has the
   <tt>succ</tt> method, there must be no member within the range
   (which means the begin must be excluded, too): 
   <tt>to_a.empty?</tt> => true
3. if the range is continuous, that is, begin does not have the
   <tt>succ</tt> method, +begin+ and +end+ must be equal
   (<tt>(begin <=> end) == 0</tt>) and both the boundaries must
   be excluded: <tt>(exclude_begin? && exclude_end?)</tt> => true.

Note that ranges with equal <tt>begin</tt> and <tt>end</tt> with inconsistent two
exclude status are not valid, as mentioned in the previous paragraph.
The built-in Range always has the begin-exclude status of
<tt>false</tt>.  For that reason, no instances of built-in Range 
have the status of <tt>empty?</tt> of <tt>true</tt>.

For more detail and examples see the documents of
{Range#empty?} 

Finally, {Range#null?} is equivalent to "either empty or not valid".
Therefore, for RangeExtd objects <tt>null?</tt> is equivalent to
<tt>empty?</tt>.

In comparison (<tt><=></tt>) between a RangeExtd and another RangeExtd or Range
object, these definitions are taken into account.
Some of them are shown in the above Examples section.
For more detail, see +Range#<=>+ and +RangeExtd#<=>+, as
well as <tt>#eql?</tt>.

Note that as long as the operation is within Range objects, the
behaviour is identical to the standard Ruby -- it is completely
backward-compatible.  Therefore, requiring this library should not affect any
existing code in principle.


== Known bugs

* This library of Version 2+ does not work in Ruby 2.6 or earlier.
* This library of Version 2+ does not work in Ruby 1.8 or earlier.
  For Ruby 1.9.3 it is probably all right, though I have never tested it.
* Some unusual (rare) boundary conditions are found to vary from
  version to version in Ruby, such as an implementation of +Hash#=>+.
  Though the test scripts are pretty extensive,
  they have not been performed over many different versions of Ruby.
  Hence, some features may not work well in some particular versions, although such
  cases should be very rare.
* {RangeExtd#hash} method does not theoretically guarantee to return a unique
  number for a {RangeExtd} object, though to encounter a hash number that is
  used elsewhere is extremely unlikely to happen in reality.

Extensive tests have been performed, as included in the package.

== ToDo

Nothing on the horizon.

== History memo

* <tt>((?a..?z) === "cc")</tt> would give false with Ruby 2.6.x or earlier, but true if later.
* <tt>(Float::INFINITY..Float::INFINITY).size</tt> used to return 0
  (in Ruby-2.1 at least) but raises +FloatDomainError: NaN+ as of
  Ruby-2.6 and later, including Ruby 3. I do not know in which version
  the behaviour changed.


=== RangeExtd Ver.2

The paths for the libraries are moved up by one directory in {RangeExtd} Ver.2 from Ver.1 in order that their locations follow the Ruby Gems convention.

Compatible with Beginless Range introduced in Ruby-2.7.

+RangeExtd::Infinity#succ+ is now undefined, in line with Float.

=== RangeExtd Ver.1.1

As of Ver.1.1, the +RangeExtd::Infinity+ class instances are not
comparable with +Float::INFINITY+; for example,

  RangeExtd::Infinity::POSITIVE != Float::INFINITY  # => true

Conceptionally, the former is a generalised object of the latter and
hence they should not be *equal*.  See the reference of
{RangeExtd::Infinity} for detail.  Note, the behaviour of Endless Range from Ruby 2.6
may feel a little odd, as follows:

  num1 = (5..Float::INFINITY)
  num2 = (5..)
  num1.end != num2.end  # => true
  num1.size              # => Infinity
  num2.size              # => Infinity

  str1 = (?a..)
  str1.end == num2.end   # => true (because both are nil)
  str1.size              # => nil

=== RangeExtd Ver.1.0

+RangeExtd::Infinity::POSITIVE+ is practically the same as
{Endless Range}[https://rubyreferences.github.io/rubychanges/2.6.html#endless-range-1]
introduced in Ruby 2.6 released in 2018 December!!  In other words,
the official Ruby has finally implement a part of this library!
However, +RangeExtd::Infinity::NEGATIVE+ was not yet implemented (at
the time) in the
official Ruby Range (it has no "boundless begin").


== Final notes

All the behaviours within RangeExtd (not Range), such as
any comparison between two RangeExtd, should be (or hopefully?)
natural for you.  At least it is well-defined and self-consistent, as
the logical structure of the ranges is now complete with {RangeExtd}.

In this section in the earlier versions, I wrote:

> Note that some behaviours for open-ended or begin-excluded ranges may
give you a little shock at first.  For example, the method
<tt>member?(obj)</tt> for an open-ended range for the negative direction with
discrete elements returns <tt>nil</tt>.  That is because no meaningful method
of <tt>succ()</tt> is defined for the (negative) infinity, hence it is
theoretically impossible in general to check whether the given obj is a member of
the range or not.  You may find it to be weird, but that just means
the concept of the infinity is unfamiliar to us mortals!

Now, interestingly, the introduction of "beginless Range" in Ruby
means everyone Ruby programmer must be familiar with the concept!
I would call it a progress.

Still, comparisons between RangeExtd and Range may give you
occasional surprises.  This is because some of the accepted
ranges by built-in Range class are no longer valid in this framework with the
inclusion of exclude-status of the begin boundary, as explained.
Hopefully you will feel it natural as you get accustomed to it.
And I bet once you have got accustomed to it, you will never want to
go back to the messy world of logical incompleteness, that is, the
current behaviour of Range!

Enjoy.


== Miscellaneous

== Copyright etc

Author::  Masa Sakano < info a_t wisebabel dot com >
License:: MIT.
Warranty:: No warranty whatsoever.
Versions:: The versions of this package follow Semantic Versioning (2.0.0) http://semver.org/

----------

= RangeExtd - 拡張Rangeクラス - exclude_begin と無限大に開いた範囲と

このパッケージは、Range を拡張した RangeExtd クラスを定義しています。
以下の特徴を持ちます。

 1. メソッド exclude_begin? の導入 (レンジの始点を除外できる),
 2. (無限大に)開いたレンジ
 3. NONE (空レンジ) と ALL (全範囲レンジ)定数の導入
 4. 初めて自己論理的に完結したレンジ構造の達成
 5. 組込Rangeとの完全後方互換性

組込Rangeにある exclude_end に加えて、exclude_beginを導入したこと、及
び無限大へ開いた範囲を許可したことで、一次元上の範囲の論理的完全性を実
現しました。

これにより、レンジの有効性を厳密に定義しています。それに従って、数個の
メソッドを Range及び(自然に)そのサブクラスに追加しました。なかでも特徴的なのが、
{Range#valid?} と {Range#empty?} です。

たとえば、<tt>(3...3).valid?</tt> は偽を返します。要素の 3 が、始点と
しては含まれているのに対し、終点としては除外されていて、これは相互に矛
盾しているためです。ここで導入する RangeExtdクラスにおいては、以下のよ
うにこれが有効なレンジとして定義できます。

* RangeExtd.new(3, 3, true,  true)   # => 空レンジ
* RangeExtd.new(3, 3, false, false)  # => 一点レンジ (3..3)

しかしながら、組込Rangeの範囲内に収まっている限り、何も変わっていませ
ん。つまり、標準の Rubyとの完全な後方互換性を実現しています。

無限に開いたレンジを表すのは簡単です。単に {RangeExtd::Infinity}クラスで
定義されている二つの定数(無限大または無現小、あるいは無限前と無限後)の
いずれかを用います。

* RangeExtd::Infinity::NEGATIVE
* RangeExtd::Infinity::POSITIVE

これらは基本的に <tt>Float::INFINITY</tt> を全ての Comparableであるオ
ブジェクトに一般化したものです。たとえば、

   ("a"..RangeExtd::Infinity::POSITIVE).each

は、"a"から始まる <tt>String#succ</tt> を使った無限のイテレーターを与えます
(だから、どこかで必ず breakするようにコードを書きましょう!)。

組込 Rangeは大変有用なクラスであり、Rubyユーザーに容易なプログラミングを可能にす
るツールでした。しかし、始点を除外することができないのが玉に瑕でありました。

ただし、それにはれっきとした理由があることは分かります。Rubyの Rangeは、Numeric
(厳密にはその実数を表現したもの)だけに限ったものではありません。 <tt>succ()</tt> メソッ
ドを持つオブジェクトによる Rangeは極めて有用です。一方、<tt>succ()</tt> の逆に相
当するメソッドは一般的には定義されていません。そういう意味で、Rangeは本質的に非
対称です。加えて、よく使われる Rangeオブジェクトのうちあるもの(たとえば Float)は
連続的なのに対し、そうでないものも普通です(たとえば Integer や String)。この状況
が厳密な定義をする時の混乱に拍車をかけています。

ここで始点を除外可能としたことは、そういう意味で、道筋が100パーセント明らかなも
のではありませんでした。ここで私が採用した RangeExtdクラスの定義は、おそらく、考え
られる唯一のものではないでしょう。とはいえ、個人的には満足のいくものに仕上がりま
したし、このレンジという枠内での論理的完全性をうまく達成できたと思います。

このクラスが少なからぬ人に有用なものであることを願ってここにリリースします。


=== News: Endless Range サポートしました

2019年10月より、本パッケージは、Ruby 2.6 で導入された {Endless Range}[https://rubyreferences.github.io/rubychanges/2.6.html#endless-range-1]
(終端のない Range)を正式サポートしました。よって、Version 1.0 をリリースしました!

Ruby 2.7 では、{Beginless range}[https://rubyreferences.github.io/rubychanges/2.7.html#beginless-range] が導入されました.

==== 注: Rangearyとの関係

同クラス(典型的にはFloat)のオブジェクトからなる複数のRangeを扱うクラス
{Rangeary}[https://rubygems.org/gems/rangeary] は、本ライブラリを使い
切っています。Rangeを実現するためには、始端と終端との両方で開いた可能
性があるRangeを扱うことが必須だからです。例えば、
Range +(?a..?d)+ の否定は、複数Range +(-"Infinity(文字)"...3)+ と
+(?d(始端除外).."Infinity(文字)")+ であり、その否定は、元の +(?a..?d)+
です。このような演算は、+RangeExtd+ があって初めて可能になります。

Rangeary: https://rubygems.org/gems/rangeary

==== 注: Rangesmallerとの関係

このパッケージは、(今やサポートされていない) {Rangesmaller}[https://rubygems.org/gems/rangesmaller] パッケージ及びクラスを
後継するものです。同クラスの機能に、無限に開いた範囲を許す機能が加わり、また、オ
ブジェクト生成時のインターフェースが変更されています。
https://rubygems.org/gems/rangesmaller

== インストール

  gem install range_extd

により、ファイルが 2個、

  range_extd/range_extd.rb
  range_extd/infinity/infinity.rb

<tt>$LOAD_PATH</tt> の一カ所にインストールされるはずです。

あるいは、パッケージを以下から入手できます。

  http://rubygems.org/gems/range_extd

後は、Ruby のコード(又は irb)から

  require 'range_extd/range_extd'

とするだけです。もしくは、特に手でインストールした場合は、

  require 'range_extd'

とする必要があるかも知れません。もう一方のファイル

  range_extd/infinity/infinity.rb

は、自動的に読み込まれます。

お楽しみあれ!


== 単純な使用例

=== RangeExtd インスタンスを作成する方法

以下に幾つかの基本的な使用例を列挙します。

   r = RangeExtd(?a...?d, true)  # => a<...d
   r.exclude_begin?              # => true 
   r.to_a                        # => ["b", "c"]
   RangeExtd(1...2)            == (1...2)          # => true
   RangeExtd(1, 2, false, true)== (1...2)          # => true
   RangeExtd(1, 1, false, false)==(1..1)           # => true
   RangeExtd(1, 1, true, true) == RangeExtd::NONE  # => true
   RangeExtd(1, 1, false, true)  # => ArgumentError
   (RangeExtd::Infinity::NEGATIVE..RangeExtd::Infinity::POSITIVE) \
    == RangeExtd::ALL  # => true

インスタンスを作成する方法が3通りあります。

   RangeExtd(range, [exclude_begin=false, [exclude_end=false]], opts)
   RangeExtd(obj_begin, obj_end, [exclude_begin=false, [exclude_end=false]], opts)
   RangeExtd(obj_begin, string_form, obj_end, [exclude_begin=false, [exclude_end=false]], opts)

大括弧の中の二つのパラメーターが、それぞれ始点と終点とを除外する(true)、または含む
(false)を指示します。もし、その二つのパラメーターが最初のパラメーターのレンジ
(Range or RangeExtd) と矛盾する場合は、ここで与えた二つのパラメーターが優先され
ます。同じパラメーターをオプションHash
(<tt>:exclude_begin</tt> と <tt>:exclude_end</tt>)で指定することもできて、
もし指定されればそれらが最高の優先度を持ちます。
第三の方法の <tt>string_form</tt> とは、".." や "<..."のことで、ユーザー定義
も可能です(詳しくは {RangeExtd.middle_strings=}() を参照のこと)。これが、
視覚的には最もわかりやすい方法かも知れません。

<tt>RangeExtd.new()</tt> も上と同意味です。
さらなる解説及び例は、{RangeExtd.initialize}を参照して下さい。


=== 少し上級編

   (1..RangeExtd::Infinity::POSITIVE).each do |i|
     print i
     break if i >= 9
   end    # => self ( "123456789" => STDOUT )
   (nil..nil).valid?  # => false
   (1...1).valid?     # => false
   (1...1).null?      # => true
   RangeExtd.valid?(1...1)              # => false
   RangeExtd(1, 1, true, true).valid?   # => true
   RangeExtd(1, 1, true, true).empty?   # => true
   RangeExtd(?a, ?b, true, true).to_a?  # => []
   RangeExtd(?a, ?b, true, true).empty? # => true
   RangeExtd(?a, ?e, true, true).to_a?  # => ["b", "c", "d"]
   RangeExtd(?a, ?e, true, true).empty? # => false
   RangeExtd::NONE.is_none?             # => true
   RangeExtd::ALL.is_all?               # => true
   (3...7).equiv?(3..6)    # => true

組込Rangeに含まれる全てのメソッドが使用可能です。


== 詳説

ファイル +range_extd/range_extd.rb+ が読まれた段階で、次の二つのクラスが定義されます。

* RangeExtd
* RangeExtd::Infinity

加えて、Range クラスに数個のメソッドが追加また改訂されます。Rangeクラスに加えら
れる改変は、全て後方互換性を保っています。

=== RangeExtd::Infinity クラス

{RangeExtd::Infinity} クラスは、基本、定数二つのみを保持するものです。

* RangeExtd::Infinity::NEGATIVE
* RangeExtd::Infinity::POSITIVE

これらは、 <tt>Float::INFINITY</tt> を全ての Comparable なオブジェクトに一般化し
たものです。メソッド <tt><=></tt> と <tt>succ</tt> が定義されています。

これらは、他のオブジェクトと同様に普通に使用可能です。たとえば、
  ("k"..RangeExtd::Infinity::POSITIVE)
とはいえ、他には何もメソッドを持っていないため、 Range型のクラスの中以外での使用
はおそらく意味がないでしょう。

なお、Numericのオブジェクトに対しては、原則として <tt>Float::INFINITY</tt> の方
を使って下さい。

ユーザー定義のどの Comparable なクラスに属するどのオブジェクトも、これら二定数と
可換的に比較可能です。その際、同クラスに置ける比較メソッドがマナー良く書かれてあ
る、という前提で。

さらに詳しくは、マニュアルを参照して下さい(YARD　または RDoc形式で書かれた文書が
コード内部に埋込まれていますし、{RubyGemsのウェブサイト}[http://rubygems.org/gems/range_extd]でも閲覧できます。

**(注)** +RangeExtd::Infinity::POSITIVE+ は、
2018年12月に公式リリースされたRuby 2.6で導入された
{Endless Range}[https://rubyreferences.github.io/rubychanges/2.6.html#endless-range-1]
(終端のないRange)で実用上同一です!! 言葉を替えれば、公式Rubyがついに本
ライブラリの一部をサポートしました! ただし、公式Rubyには、
+RangeExtd::Infinity::NEGATIVE+ は依然ありません(始端のないRangeがない)。
本ライブラリにより、組込Rangeに欠けている数学的不完全性を補うことができます。


=== RangeExtd クラス

RangeExtd のインスタンスは、 Rangeと同じくイミュータブルです。だから、一度インス
タンスが生成されると、変化しません。

インスタンスの生成方法は上述の通りです(「使用例」の章)。レンジとして"valid"(後述)と見
なされないインスタンスを生成しようとすると、例外(<tt>ArgumentError</tt>)が発生し、
失敗します。

このクラスには、二つの定数が定義されています。

* RangeExtd::NONE
* RangeExtd::ALL

前者は、空レンジを表し、後者は全てを含むレンジ、すなわち正負両方向に開いたレンジを表します。

{Range}クラスの通常のメソッド全てに加え、以下が {RangeExtd} と {Range}クラス両方に加え
られています。詳細は、各メソッドのマニュアルを参照下さい(注: 幾つかのメソッドは
{Range}クラスのみで定義されていて、 {RangeExtd} はそれを継承しています)。

* <tt>exclude_begin?</tt>  ({Range}クラスでは未定義)
* <tt>valid?</tt> 
* <tt>empty?</tt> 
* <tt>null?</tt> 
* <tt>is_none?</tt> 
* <tt>is_all?</tt> 
* <tt>equiv?</tt> 

クラスメソッドが三つあります。一番上のものは、
インスタンスメソッドの <tt>valid?</tt> に等価です。

* <tt>RangeExtd.valid?</tt> 
* <tt>RangeExtd.middle_strings=(ary)</tt> 
* <tt>RangeExtd.middle_strings</tt> 

何がレンジとして有効 (<tt>#valid?</tt> => true) かの定義は以下です。

1. 始点と終点とが互いに Comparable であり、かつその比較結果に矛盾がないこと。
   この唯一の例外は {RangeExtd::NONE} で、これは valid です。
   たとえば、<tt>(nil..nil)</tt> は valid では「ありません」(参考までに、この例は
   Ruby 1.8 では例外を生じていました)。
2. 始点は終点と等しい(<tt>==</tt>)か小さくなければなりません。すなわし、
   <tt>(begin <=> end)</tt> は、-1 または 0 を返すこと。
3. もし始点と終点とが等しい時、すなわち <tt>(begin <=> end) == 0</tt>ならば、
   端を除外するかどうかのフラグは両端で一致していなければなりません。
   すなわち、もし始点が除外ならば、終点も除外されていなくてはならず、逆も真です。
   その一例として、 <tt>(1...1)</tt> は、"valid" では「ありません」。なぜならば
   組込レンジでは、始点を常に含むからです。

さらなる詳細は {RangeExtd.valid?} と {Range#valid?} のマニュアルを
参照して下さい。

何がレンジとして空(<tt>#empty?</tt> => true)かの定義は以下の通りです。

1. レンジは、valid であること: <tt>valid?</tt> => true
2. もしレンジの要素が離散的であれば、すなわち始点の要素がメソッド <tt>succ</tt>
   を持っていれば、レンジ内部に要素が一つも無いことが条件(当然、始点のフラグ
   は除外になっていなければなりません): <tt>to_a.empty?</tt> => true
3. もしレンジが連続的であれば、すなわち始点の要素がメソッド <tt>succ</tt> を持っ
   ていなければ、始点と終点とが等しく (<tt>(begin <=> end)</tt> => 0)、かつ両端
   のフラグが除外になっていること: <tt>(exclude_begin? && exclude_end?)</tt> => true.

なお、始点と終点とが等しい一方でその除外フラグが一致しない場合は、前節で述べたよ
うに "valid"ではありません。組込レンジは、始点除外フラグが常に偽(<tt>false</tt>)で
す。そのため、組込Rangeのオブジェクトで、<tt>empty?</tt> が真(<tt>true</tt>)にな
ることはありません。

さらなる詳細は {Range#empty?} のマニュアルを
参照して下さい。


最後、 {Range#null?} は、「<tt>empty?</tt> または "valid"でない」ことに等
価です。従って、 RangeExtd オブジェクトにとっては、<tt>null?</tt> は
<tt>empty?</tt> に等価です。

RangeExtd と別の RangeExtd または Rangeの比較 (<tt><=></tt>) においては、これら
の定義が考慮されます。そのうちの幾つかは、上の「使用例」の項に示されています。
さらなる詳細は {Range#==}、{RangeExtd#==} および
<tt>#eql?</tt> のマニュアルを参照して下さい。

なお、処理が Rangeオブジェクト内部で閉じている限り、その振舞いは標準 Rubyと同一
で、互換性を保っています。したがって、このライブラリを読込むことで既存のコードに
影響を与えることは原理的にないはずです。


== 既知のバグ

* このライブラリは Ruby 1.8 およびそれ以前のバージョンでは動作しません。
  Ruby 1.9.3 ではおそらく大丈夫でしょうが、私は試したことがありません。
* いくつかの極めて稀な境界条件に於ける挙動は、Rubyのバージョンごとにあ
  る程度変化しています。例えば、Float::INFINITY 同士の比較などの挙動が
  異なります。同梱のテストスクリプトはかなり網羅的ではあるものの、Ruby
  の多数のバージョンでテストはしておりません。したがって、バージョンに
 よっては、(極めて稀でしょうが)問題が発生する可能性が否定できません。
* {RangeExtd#hash} メソッドは、ある RangeExtdオブジェに対して常に唯一で排他的な
  数値を返すことが理論保証はされていません。ただし、現実的にそれが破られることは、まず
  ありません。

パッケージに含まれている通り、網羅的なテストが実行されています。


== 開発項目

特になし。


== 履歴メモ

* <tt>((?a..?z) === "cc")</tt> は、Ruby 2.6.x 以前は false を返していたが、2.7 以降は true を返す。

== 終わりに

RangeExtd内部に閉じた(Rangeでなく)挙動、たとえば RangeExtd同士の比較などは、
全てユーザーにとって自然なもののはずです(と期待します?)。少なくとも、RangeExtdに
よってレンジの論理構造が完結した今、これはよく定義されかつ自己矛盾が無いものと言
えましょう。ただ、端の無限に開いた、あるいは始点が除外されたレンジの挙動には、
一瞬ぎょっとするものが無くはないかも知れないことに注意して下さい。たとえば、
片端が小さい方向に無限に開いて離散的な要素を持つレンジに対してメソッド
<tt>member?(obj)</tt> を実行すると、 <tt>nil</tt>が返ります。これは、無限(小)に
は実質的な意味を持つ <tt>succ()</tt> メソッドが定義されていないためで、したがっ
て与えられた objがレンジの要素(member)かどうかを調べることが、一般論としては理論
的に不可能だからです。これはちょっと不思議に思うかも知れませんが、それはつまり定
命の私たちには無限という概念を計り知るのが容易でない、というだけの話でしょう!

一方、RangeExtd と Range との比較は、それ以上に驚くことがあるかも知れません。こ
れは、組込Rangeクラスで許容されているレンジの一部は、始点を除外することを認めた
枠組の中では、前述のように最早有効(valid)と見なされないからです。この枠組に慣れるに
したがって、それらが自然だと思えるようになればいいのですが。保証しますが、一旦こ
れに慣れてしまえば、論理的不完全さ極まる混沌とした世界、つまりは Rangeの現在の挙
動には二度と戻りたくなくなることでしょう!

お楽しみ下さい。


== その他

== 著作権他情報

著者::  Masa Sakano < info a_t wisebabel dot com >
利用許諾条項:: MIT.
保証:: 一切無し。
バージョン:: Semantic Versioning (2.0.0) http://semver.org/

