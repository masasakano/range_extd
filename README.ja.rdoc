
= RangeExtd - Extended Range class with exclude_begin and open-ends

This package contains RangeExtd class, the Extended Range class that features:

 1. includes exclude_begin? (to exclude the "begin" boundary),
 2. allows open-ended range (to the infinity),
 3. defines NONE and ALL constants,
 4. the first self-consistent logical structure,
 5. complete backward-compatibility within the built-in Range.

With the introduction of the excluded status of begin, in addition
to the end as in built-in Range, and open-ended feature,
the logical completeness of the 1-dimensional range is realised.

Then the validity of range is strictly defined now.
Following that, this package adds a few methods, most notably
{Range#valid?} and {Range#empty?}
to Range, and accordingly its any sub-classes,

For example, <tt>(3...3).valid?</tt>  returns false, because the element 3 is
inclusive for the begin boundary, yet exclusive for the end boundary,
which are contradictory to each other.  With this RangeExtd class,
it is expressed as a valid range,
* RangeExtd.new(3, 3, true,  true)   # => an empty range
* RangeExtd.new(3, 3, false, false)  # => a single-point range (3..3)

However, as long as it is within built-in Range, nothing has changed,
so it is completely compatible with the standard Ruby.

To express open-ended ranges is simple; you just use either of
the two (negative and positive, or former and later) constants
defined in the class {RangeExtd::Infinity}
* RangeExtd::Infinity::NEGATIVE
* RangeExtd::Infinity::POSITIVE

They are basically the object that generalised <tt>Float::INFINITY</tt> to
any Comparable object.  For example,
   ("a"..RangeExtd::Infinity::POSITIVE).each
gives an infinite iterator with <tt>String#succ</tt>, starting from "a"
(therefore, make sure to code so it breaks the iterator at one stage!).


The built-in Range class is very useful, and has given Ruby users
a power to make easy coding.  Yet, the lack of definition of
exclusive begin boundary is a nuisance in some cases.

Having said that, there is a definite and understandable reason;
Range in Ruby is not limited at all to Numeric (or strictly speaking,
Real number or its representative).  Range with any object that has a method
of <tt>succ()</tt> is found to be useful, whereas there is no reverse method for
<tt>succ()</tt> in general.
In that sense Range is inherently not symmetric.  In addition
some regular Range objects are continuous (like Float), while others are discrete
(like Integer or String).  That may add some confusion to the strict definition.

To add the feature of the exclusive begin boundary is in that sense
not 100 per cent trivial.  The definition I adopt for the behaviour of
RangeExtd is probably not the only solution.  Personally, I am content
with it, and I think it achieves the good logical completeness within the frame.

I hope you find it to be useful.


==== NOTE: Relationship with Rangesmaller

This package supercedes the obsolete Rangesmaller package and class,
with the added open-ended feature, and a different interface in
creating a new instance.
{https://rubygems.org/gems/rangesmaller}


== Install

  gem install range_extd

Two files
  range_extd/range_extd.rb
  range_extd/infinity/infinity.rb
should be installed in one of your <tt>$LOAD_PATH</tt> 

Alternatively get it from
  http://rubygems.org/gems/range_extd

Then all you need to do is
  require 'range_extd/range_extd'
or, possibly as follows, if you manually install it
  require 'range_extd'
in your Ruby script (or irb).  The other file
  range_extd/infinity/infinity.rb
is called (required) from it automatically.

Have fun!


== Simple Examples

=== How to create a RangeExtd instance

Here are some simple examples.

   r = RangeExtd(?a...?d, true)  # => a<...d
   r.exclude_begin?              # => true 
   r.to_a                        # => ["b", "c"]
   RangeExtd(1...2)            == (1...2)          # => true
   RangeExtd(1, 2, false, true)== (1...2)          # => true
   RangeExtd(1, 1, false, false)==(1..1)           # => true
   RangeExtd(1, 1, true, true) == RangeExtd::NONE  # => true
   RangeExtd(1, 1, false, true)  # => ArgumentError
   (RangeExtd::Infinity::NEGATIVE..RangeExtd::Infinity::POSITIVE) \
    == RangeExtd::ALL  # => true

Basically, there are two forms:

   RangeExtd(range, [exclude_begin=false, [exclude_end=false]], opts)
   RangeExtd(obj_begin, obj_end, [exclude_begin=false, [exclude_end=false]], opts)

The two parameters in the brackets specify the respective boundary to be excluded if true,
or included if false (Default).  If they contradict to the first
parameter of the range (Range or RangeExtd), those latter two parameters are used.
Also, you can specify the same parameters as the options <tt>:exclude_begin</tt>
and <tt>:exclude_end</tt>, which have the highest priority, if specified.
<tt>RangeExtd.new()</tt> is the same thing.

=== Slightly more advanced uses

   (1..RangeExtd::Infinity::POSITIVE).each do |i|
     print i
     break if i >= 9
   end    # => self ( "123456789" => STDOUT )
   (nil..nil).valid?  # => false
   (1...1).valid?     # => false
   (1...1).null?      # => true
   RangeExtd.valid?(1...1)              # => false
   RangeExtd(1, 1, true, true).valid?   # => true
   RangeExtd(1, 1, true, true).empty?   # => true
   RangeExtd(?a, ?b, true, true).to_a?  # => []
   RangeExtd(?a, ?b, true, true).empty? # => true
   RangeExtd(?a, ?e, true, true).to_a?  # => ["b", "c", "d"]
   RangeExtd(?a, ?e, true, true).empty? # => false
   RangeExtd::NONE.is_none?             # => true
   RangeExtd::ALL.is_all?               # => true

All the methods that are in the built-in Range can be used.


== Description

Once the file range_extd.rb is required, the two classes are defined:

* RangeExtd
* RangeExtd::Infinity

Also, several methods are added or altered in Range class.
All the changes made in Range are backward-compatible with the original.

=== RangeExtd::Infinity Class

Class {RangeExtd::Infinity} has basically only two constant instances.

* RangeExtd::Infinity::NEGATIVE
* RangeExtd::Infinity::POSITIVE

They are the objects that generalise the concept of
<tt>Float::INFINITY</tt> 
to any Comparable objects.  The methods <tt><=></tt> and <tt>succ</tt>  are defined.

You can use them the same as other objects, such as,
  ("k"..RangeExtd::Infinity::POSITIVE)
However as they do not have any other methods,
the use out of Range-type class is probably meaningless.

Note for any Numeric object, please use <tt>Float::INFINITY</tt> instead in principle.

Any objects in any user-defined Comparable class are commutatively comparable with
those two constants, as long as the cmp method of the class is written
politely.

For more detail, see its documents (YARD or RDoc-style
documents embedded in the code, or see RubyGems webpage).


=== RangeExtd Class

RangeExtd objects are immutable, the same as Range.
Hence once an instance is created, it would not change.

How to create an instance is explained above (in the Examples
sections).  Any attempt to try to create an instance that is not
"valid" as a range (see below) raises an exception (<tt>ArgumentError</tt>), and fails.

There are two constants defined in this class:

* RangeExtd::NONE
* RangeExtd::ALL

The former represents the empty range and the latter does the range
covers everything, namely open-ended for the both negative and
positive directions.

In addition to all the standard methods of {Range}, the following
methods are added to both {RangeExtd} and {Range} classes.
See the document of each method for detail (some are defined only in
{Range} class, as {RangeExtd} inherits it).

* <tt>exclude_begin?</tt> (not defined in {Range} class)
* <tt>valid?</tt> 
* <tt>empty?</tt> 
* <tt>null?</tt> 
* <tt>is_none?</tt> 
* <tt>is_all?</tt> 

There are three class methods, the first of which is equivalent 
to the instance method <tt>valid?</tt>:
* <tt>RangeExtd.valid?</tt> 
* <tt>RangeExtd.middle_strings=(ary)</tt> 
* <tt>RangeExtd.middle_strings</tt> 

What is valid (<tt>#valid?</tt> => true) as a range is defined as follows.

1. Both <tt>begin</tt> and <tt>end</tt> elements must be Comparable to each other,
   and the comparison results must be consistent between the two.
   The sole exception is {RangeExtd::NONE}, which is valid.
   For example, <tt>(nil..nil)</tt> is NOT valid (nb., it raised Exception in Ruby 1.8).
2. begin must be smaller than or equal (<tt>==</tt>) to end,
   that is, <tt>(begin <=> end)</tt> must be either -1 or 0.
3. If begin is equal to end, namely, <tt>(begin <=> end) == 0</tt>,
   the exclude status of the both ends must agree.
   That is, if the <tt>begin</tt> is excluded, <tt>end</tt> must be also excluded,
   and vice versa.
   For example, <tt>(1...1)</tt> is NOT valid for that reason,
   because any built-in Range object has the exclude status
   of false (namely, inclusive) for <tt>begin</tt>.

For more detail and examples see the documents of
{RangeExtd.valid?} and {Range#valid?} 

The definition of what is empty (<tt>#empty?</tt> => true) as a range is as follows;

1. the range must be valid: <tt>valid?</tt> => true
2. if the range id discrete, that is, begin has
   <tt>succ</tt> method, there must be no member within the range
   (which means the begin must be excluded, too): 
   <tt>to_a.empty?</tt> => true
3. if the range is continuous, that is, begin does not have
   <tt>succ</tt> method, begin and end must be equal
   (<tt>(begin <=> end)</tt> => 0) and both the boundaries must
   be excluded: <tt>(exclude_begin? && exclude_end?)</tt> => true.

Note that ranges with equal <tt>begin</tt> and <tt>end</tt> with inconsistent two
exclude status are not valid, as mentioned in the previous paragraph.
The built-in Range always has the begin-exclude status of
<tt>false</tt>.  For that reason, no instance of built-in Range 
has the status of <tt>empty?</tt> of <tt>true</tt>.

For more detail and examples see the documents of
{Range#empty?} 

Finally, {Range#null?} is equivalent to "either empty or not valid".
Therefore, for RangeExtd objects <tt>null?</tt> is equivalent to
<tt>empty?</tt>.

In comparison (<tt><=></tt>) between a RangeExtd and another RangeExtd or Range
object, those definitions are taken into account.
Some of them are shown in the above Examples section.
For more detail, see {Range#==}> and {RangeExtd#==}>, as
well as <tt>#eql?</tt>.

Note that as long as the operation is within Range objects, the
behaviour is identical to the standard Ruby -- it is completely
compatible.  Therefore, requiring this library would not affect any
existing code in principle.


== Known bugs

* <tt>hash()</tt> method does not always guarantee to return a unique
  and exclusive number for the equal RangeExtd object, though such an
  exception is extremely unlikely to happen in reality.

Note this library does not work in Ruby 1.8 or earlier.
For Ruby 1.9.3 it is probably all right, however I have never tested
it.

Extensive tests have been performed, as included in the package.


== ToDo

Nothing planned.


== Final notes

All the behaviours within RangeExtd (not Range), such as
any comparison between two RangeExtd, should be (or hopefully?)
natural for you.  At least it is well-defined and self-consistent, as
the logical structure of the ranges is now complete with RangeExtd.
Note some behaviours for open-ended or begin-excluded ranges may
give you a little shock at first.  For example, the method
<tt>member?(obj)</tt> for an open-ended range for the negative direction with
discrete elements returns <tt>nil</tt>.  That is because no meaningful method
of <tt>succ()</tt> is defined for the (negative) infinity, hence it is
theoretically impossible in general to check whether the given obj is a member of
the range or not.  You may find it to be weird, but that just means
the concept of the infinity is unfamiliar to us mortals!

On the other hand, the comparison between RangeExtd and Range may have
more occasional surprises.  That is because some of the accepted
ranges by built-in Range class are no longer valid in this framework with the
inclusion of exclude-status of the begin boundary, as explained.
Hopefully you will feel it to be natural as you get accustomed to it.
And I bet once you have got accustomed to it, you will never want to
go back to the messy world of logical incompleteness, that is, the
current behaviour of Range!

Enjoy.



== Miscellaneous

== Copyright etc

Author::  Masa Sakano < imagine a_t sakano dot co dot uk >
License:: MIT.
Warranty:: No warranty whatsoever.
Versions:: The versions of this package follow Semantic Versioning (2.0.0) http://semver.org/



= RangeExtd - 拡張Rangeクラス - exclude_begin と無限大に開いた範囲と

このパッケージは、Range を拡張した RangeExtd クラスを定義しています。
以下の特徴を持ちます。

 1. メソッド exclude_begin? の導入 (レンジの始点を除外できる),
 2. (無限大に)開いたレンジ
 3. NONE (空レンジ) と ALL (全範囲レンジ)定数の導入
 4. 初めて自己論理的に完結したレンジ構造の達成
 5. 組込Rangeとの完全後方互換性

組込Rangeにある exclude_end に加えて、exclude_beginを導入したこと、及
び無限大へ開いた範囲を許可したことで、一次元上の範囲の論理的完全性を実
現しました。

これにより、レンジの有効性を厳密に定義しています。それに従って、数個の
メソッドを Range及び(自然に)そのサブクラスに追加しました。なかでも特徴的なのが、
{Range#valid?} と {Range#empty?} です。

たとえば、<tt>(3...3).valid?</tt> は偽を返します。要素の 3 が、始点と
しては含まれているのに対し、終点としては除外されていて、これは相互に矛
盾しているためです。ここで導入する RangeExtdクラスにおいては、以下のよ
うにこれが有効なレンジとして定義できます。
* RangeExtd.new(3, 3, true,  true)   # => 空レンジ
* RangeExtd.new(3, 3, false, false)  # => 一点レンジ (3..3)

しかしながら、組込Rangeの範囲内に収まっている限り、何も変わっていませ
ん。つまり、標準の Rubyとの完全な後方互換性を実現しています。

無限に開いたレンジを表すのは簡単です。単に {RangeExtd::Infinity}クラスで
定義されている二つの定数(無限大または無現小、あるいは無限前と無限後)の
いずれかを用います。
* RangeExtd::Infinity::NEGATIVE
* RangeExtd::Infinity::POSITIVE

これらは基本的に <tt>Float::INFINITY</tt> を全ての Comparableであるオ
ブジェクトに一般化したものです。たとえば、
   ("a"..RangeExtd::Infinity::POSITIVE).each
は、"a"から始まる <tt>String#succ</tt> を使った無限のイテレーターを与えます
(だから、どこかで必ず breakするようにコードを書きましょう!)。

組込 Rangeは大変有用なクラスであり、Rubyユーザーに容易なプログラミングを可能にす
るツールでした。しかし、始点を除外することができないのが玉に瑕でありました。

ただし、それにはれっきとした理由があることは分かります。Rubyの Rangeは、Numeric
(厳密にはその実数を表現したもの)だけに限ったものではありません。 <tt>succ()</tt> メソッ
ドを持つオブジェクトによる Rangeは極めて有用です。一方、<tt>succ()</tt> の逆に相
当するメソッドは一般的には定義されていません。そういう意味で、Rangeは本質的に非
対称です。加えて、よく使われる Rangeオブジェクトのうちあるもの(たとえば Float)は
連続的なのに対し、そうでないものも普通です(たとえば Integer や String)。この状況
が厳密な定義をする時の混乱に拍車をかけています。

ここで始点を除外可能としたことは、そういう意味で、道筋が100パーセント明らかなも
のではありませんでした。ここで私が採用した RangeExtdクラスの定義は、おそらく、考え
られる唯一のものではないでしょう。とはいえ、個人的には満足のいくものに仕上がりま
したし、このレンジという枠内での論理的完全性をうまく達成できたと思います。

このクラスが少なからぬ人に有用なものであることを願ってここにリリースします。


==== 注: Rangesmaller との関係

このパッケージは、(今やサポートされていない) Rangesmaller パッケージ及びクラスを
後継するものです。同クラスの機能に、無限に開いた範囲を許す機能が加わり、また、オ
ブジェクト生成時のインターフェースが変更されています。
{https://rubygems.org/gems/rangesmaller}

== インストール

  gem install range_extd

により、ファイルが 2個、
  range_extd/range_extd.rb
  range_extd/infinity/infinity.rb
<tt>$LOAD_PATH</tt> の一カ所にインストールされるはずです。

あるいは、パッケージを以下から入手できます。
  http://rubygems.org/gems/range_extd

後は、Ruby のコード(又は irb)から
  require 'range_extd/range_extd'
とするだけです。もしくは、特に手でインストールした場合は、
  require 'range_extd'
とする必要があるかも知れません。もう一方のファイル
  range_extd/infinity/infinity.rb
は、自動的に読み込まれます。

お楽しみあれ!


== 単純な使用例

=== RangeExtd インスタンスを作成する方法

以下に幾つかの基本的な使用例を列挙します。

   r = RangeExtd(?a...?d, true)  # => a<...d
   r.exclude_begin?              # => true 
   r.to_a                        # => ["b", "c"]
   RangeExtd(1...2)            == (1...2)          # => true
   RangeExtd(1, 2, false, true)== (1...2)          # => true
   RangeExtd(1, 1, false, false)==(1..1)           # => true
   RangeExtd(1, 1, true, true) == RangeExtd::NONE  # => true
   RangeExtd(1, 1, false, true)  # => ArgumentError
   (RangeExtd::Infinity::NEGATIVE..RangeExtd::Infinity::POSITIVE) \
    == RangeExtd::ALL  # => true

インスタンスを作成するのには、二通りあります。

   RangeExtd(range, [exclude_begin=false, [exclude_end=false]], opts)
   RangeExtd(obj_begin, obj_end, [exclude_begin=false, [exclude_end=false]], opts)

大括弧の中の二つのパラメーターが、それぞれ始点と終点とを除外する(true)、または含む
(false)を指示します。もし、その二つのパラメーターが最初のパラメーターのレンジ
(Range or RangeExtd) と矛盾する場合は、ここで与えた二つのパラメーターが優先され
ます。同じパラメーターをオプションHash
(<tt>:exclude_begin</tt> と <tt>:exclude_end</tt>)で指定することもできて、
もし指定されればそれらが最高の優先度を持ちます。
<tt>RangeExtd.new()</tt> も上と同意味です。


=== 少し上級編

   (1..RangeExtd::Infinity::POSITIVE).each do |i|
     print i
     break if i >= 9
   end    # => self ( "123456789" => STDOUT )
   (nil..nil).valid?  # => false
   (1...1).valid?     # => false
   (1...1).null?      # => true
   RangeExtd.valid?(1...1)              # => false
   RangeExtd(1, 1, true, true).valid?   # => true
   RangeExtd(1, 1, true, true).empty?   # => true
   RangeExtd(?a, ?b, true, true).to_a?  # => []
   RangeExtd(?a, ?b, true, true).empty? # => true
   RangeExtd(?a, ?e, true, true).to_a?  # => ["b", "c", "d"]
   RangeExtd(?a, ?e, true, true).empty? # => false
   RangeExtd::NONE.is_none?             # => true
   RangeExtd::ALL.is_all?               # => true

組込Rangeに含まれる全てのメソッドが使用可能です。


== 詳説

ファイル range_extd.rb が読まれた段階で、次の二つのクラスが定義されます。

* RangeExtd
* RangeExtd::Infinity

加えて、Range クラスに数個のメソッドが追加また改訂されます。Rangeクラスに加えら
れる改変は、全て後方互換性を保っています。

=== RangeExtd::Infinity クラス

{RangeExtd::Infinity} クラスは、基本、定数二つのみを保持するものです。

* RangeExtd::Infinity::NEGATIVE
* RangeExtd::Infinity::POSITIVE

これらは、 <tt>Float::INFINITY</tt> を全ての Comparable なオブジェクトに一般化し
たものです。メソッド <tt><=></tt> と <tt>succ</tt> が定義されています。

これらは、他のオブジェクトと同様に普通に使用可能です。たとえば、
  ("k"..RangeExtd::Infinity::POSITIVE)
とはいえ、他には何もメソッドを持っていないため、 Range型のクラスの中以外での使用
はおそらく意味がないでしょう。

なお、Numericのオブジェクトに対しては、原則として <tt>Float::INFINITY</tt> の方
を使って下さい。

ユーザー定義のどの Comparable なクラスに属するどのオブジェクトも、これら二定数と
可換的に比較可能です。その際、同クラスに置ける比較メソッドがマナー良く書かれてあ
る、という前提で。

さらに詳しくは、マニュアルを参照して下さい(YARD　または RDoc形式で書かれた文書が
コード内部に埋込まれていますし、それが RubyGemsのウェブサイトでも閲覧できます。


=== RangeExtd クラス

RangeExtd のインスタンスは、 Rangeと同じくイミュータブルです。だから、一度インス
タンスが生成されると、変化しません。

インスタンスの生成方法は上述の通りです(「使用例」の章)。レンジとして"valid"(後述)と見
なされないインスタンスを生成しようとすると、例外(<tt>ArgumentError</tt>)が発生し、
失敗します。

このクラスには、二つの定数が定義されています。

* RangeExtd::NONE
* RangeExtd::ALL

前者は、空レンジを表し、後者は全てを含むレンジ、すなわち正負両方向に開いたレンジを表します。

{Range}クラスの通常のメソッド全てに加え、以下が {RangeExtd} と {Range}クラス両方に加え
られています。詳細は、各メソッドのマニュアルを参照下さい(注: 幾つかのメソッドは
{Range}クラスのみで定義されていて、 {RangeExtd} はそれを継承しています)。

* <tt>exclude_begin?</tt>  ({Range}クラスでは未定義)
* <tt>valid?</tt> 
* <tt>empty?</tt> 
* <tt>null?</tt> 
* <tt>is_none?</tt> 
* <tt>is_all?</tt> 

クラスメソッドが三つあります。一番上のものは、
インスタンスメソッドの <tt>valid?</tt> に等価です。
* <tt>RangeExtd.valid?</tt> 
* <tt>RangeExtd.middle_strings=(ary)</tt> 
* <tt>RangeExtd.middle_strings</tt> 

何がレンジとして有効 (<tt>#valid?</tt> => true) かの定義は以下です。

1. 始点と終点とが互いに Comparable であり、かつその比較結果に矛盾がないこと。
   この唯一の例外は {RangeExtd::NONE} で、これは valid です。
   たとえば、<tt>(nil..nil)</tt> は valid では「ありません」(参考までに、この例は
   Ruby 1.8 では例外を生じていました)。
2. 始点は終点と等しい(<tt>==</tt>)か小さくなければなりません。すなわし、
   <tt>(begin <=> end)</tt> は、-1 または 0 を返すこと。
3. もし始点と終点とが等しい時、すなわち <tt>(begin <=> end) == 0</tt>ならば、
   端を除外するかどうかのフラグは両端で一致していなければなりません。
   すなわち、もし始点が除外ならば、終点も除外されていなくてはならず、逆も真です。
   その一例として、 <tt>(1...1)</tt> は、"valid" では「ありません」。なぜならば
   組込レンジでは、始点を常に含むからです。

さらなる詳細は {RangeExtd.valid?} と {Range#valid?} のマニュアルを
参照して下さい。

何がレンジとして空(<tt>#empty?</tt> => true)かの定義は以下の通りです。

1. レンジは、valid であること: <tt>valid?</tt> => true
2. もしレンジの要素が離散的であれば、すなわち始点の要素がメソッド <tt>succ</tt>
   を持っていれば、レンジ内部に要素が一つも無いことが条件(当然、始点のフラグ
   は除外になっていなければなりません): <tt>to_a.empty?</tt> => true
3. もしレンジが連続的であれば、すなわち始点の要素がメソッド <tt>succ</tt> を持っ
   ていなければ、始点と終点とが等しく (<tt>(begin <=> end)</tt> => 0)、かつ両端
   のフラグが除外になっていること: <tt>(exclude_begin? && exclude_end?)</tt> => true.

なお、始点と終点とが等しい一方でその除外フラグが一致しない場合は、前節で述べたよ
うに "valid"ではありません。組込レンジは、始点除外フラグが常に偽(<tt>false</tt>)で
す。そのため、組込Rangeのオブジェクトで、<tt>empty?</tt> が真(<tt>true</tt>)にな
ることはありません。

さらなる詳細は {Range#empty?} のマニュアルを
参照して下さい。


最後、 {Range#null?} は、「<tt>empty?</tt> または "valid"でない」ことに等
価です。従って、 RangeExtd オブジェクトにとっては、<tt>null?</tt> は
<tt>empty?</tt> に等価です。

RangeExtd と別の RangeExtd または Rangeの比較 (<tt><=></tt>) においては、これら
の定義が考慮されます。そのうちの幾つかは、上の「使用例」の項に示されています。
さらなる詳細は {Range#==}、{RangeExtd#==} および
<tt>#eql?</tt> のマニュアルを参照して下さい。

なお、処理が Rangeオブジェクト内部で閉じている限り、その振舞いは標準 Rubyと同一
で、互換性を保っています。したがって、このライブラリを読込むことで既存のコードに
影響を与えることは原理的にないはずです。


== 既知のバグ

* <tt>hash()</tt> メソッドは、等しい RangeExtdオブジェに対して常に唯一で排他的な
  数値を返すことが保証されていません。ただし、現実的にそれが破られることは、まず
  ありません。

このライブラリは Ruby 1.8 およびそれ以前のバージョンでは動作しません。
Ruby 1.9.3 ではおそらく大丈夫でしょうが、私は試したことがありません。

パッケージに含まれている通り、網羅的なテストが実行されています。


== 未処理事項

特になし。


== 終わりに

RangeExtd内部に閉じた(Rangeでなく)挙動、たとえば RangeExtd同士の比較などは、
全てユーザーにとって自然なもののはずです(と期待します?)。少なくとも、RangeExtdに
よってレンジの論理構造が完結した今、これはよく定義されかつ自己矛盾が無いものと言
えましょう。ただ、端の無限に開いた、あるいは始点が除外されたレンジの挙動には、
一瞬ぎょっとするものが無くはないかも知れないことに注意して下さい。たとえば、
片端が小さい方向に無限に開いて離散的な要素を持つレンジに対してメソッド
<tt>member?(obj)</tt> を実行すると、 <tt>nil</tt>が返ります。これは、無限(小)に
は実質的な意味を持つ <tt>succ()</tt> メソッドが定義されていないためで、したがっ
て与えられた objがレンジの要素(member)かどうかを調べることが、一般論としては理論
的に不可能だからです。これはちょっと不思議に思うかも知れませんが、それはつまり定
命の私たちには無限という概念を計り知るのが容易でない、というだけの話でしょう!

一方、RangeExtd と Range との比較は、それ以上に驚くことがあるかも知れません。こ
れは、組込Rangeクラスで許容されているレンジの一部は、始点を除外することを認めた
枠組の中では、前述のように最早有効(valid)と見なされないからです。この枠組に慣れるに
したがって、それらが自然だと思えるようになればいいのですが。保証しますが、一旦こ
れに慣れてしまえば、論理的不完全さ極まる混沌とした世界、つまりは Rangeの現在の挙
動には二度と戻りたくなくなることでしょう!

お楽しみ下さい。


== その他

== 著作権他情報

著者::  Masa Sakano < imagine a_t sakano dot co dot uk >
利用許諾条項:: MIT.
保証:: 一切無し。
バージョン:: Semantic Versioning (2.0.0) http://semver.org/

