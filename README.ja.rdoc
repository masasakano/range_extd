# -*- coding: utf-8 -*- 

= RangeExtd - 拡張Rangeクラス - exclude_begin と無限大に開いた範囲と

このパッケージは、Range を拡張した RangeExtd クラスを定義しています。
以下の特徴を持ちます。

 1. メソッド exclude_begin? の導入 (レンジの始点を除外できる),
 2. (無限大に)開いたレンジ
 3. NONE (空レンジ) と EVERYTHING (全範囲レンジ)定数の導入
 4. 初めて自己論理的に完結したレンジ構造の達成
 5. 組込Rangeとの完全後方互換性

組込Rangeにある exclude_end に加えて、exclude_beginを導入したこと、及
び無限大へ開いた範囲を許可したことで、一次元上の範囲の論理的完全性を実
現しました。

これにより、レンジの有効性を厳密に定義しています。それに従って、数個の
メソッドを Range及び(自然に)そのサブクラスに追加しました。なかでも特徴的なのが、
<tt>Range#valid?</tt> と <tt>Range#empty?</tt> です。

たとえば、<tt>(3...3).valid?</tt> は偽を返します。要素の 3 が、始点と
しては含まれているのに対し、終点としては除外されていて、これは相互に矛
盾しているためです。ここで導入する RangeExtdクラスにおいては、以下のよ
うにこれが有効なレンジとして定義できます。
* RangeExtd.new(3, 3, true,  true)   # => 空レンジ
* RangeExtd.new(3, 3, false, false)  # => 一点レンジ (3..3)

しかしながら、組込Rangeの範囲内に収まっている限り、何も変わっていませ
ん。つまり、標準の Rubyとの完全な後方互換性を実現しています。

無限に開いたレンジを表すのは簡単です。単に RangeExtd::Infinityクラスで
定義されている二つの定数(無限大または無現小、あるいは無限前と無限後)の
いずれかを用います。
* RangeExtd::Infinity::NEGATIVE
* RangeExtd::Infinity::POSITIVE

これらは基本的に <tt>Float::INFINITY</tt> を全ての Comparableであるオ
ブジェクトに一般化したものです。たとえば、
   <tt>("a"..RangeExtd::Infinity::POSITIVE).each</tt>
は、"a"から始まる <tt>String#succ</tt> を使った無限のイテレーターを与えます
(だから、どこかで必ず breakするようにコードを書きましょう!)。

組込 Rangeは大変有用なクラスであり、Rubyユーザーに容易なプログラミングを可能にす
るツールでした。しかし、始点を除外することができないのが玉に瑕でありました。

ただし、それにはれっきとした理由があることは分かります。Rubyの Rangeは、Numeric
(厳密にはその実数を表現したもの)だけに限ったものではありません。 <tt>succ()</tt> メソッ
ドを持つオブジェクトによる Rangeは極めて有用です。一方、<tt>succ()</tt> の逆に相
当するメソッドは一般的には定義されていません。そういう意味で、Rangeは本質的に非
対称です。加えて、よく使われる Rangeオブジェクトのうちあるもの(たとえば Float)は
連続的なのに対し、そうでないものも普通です(たとえば Integer や String)。この状況
が厳密な定義をする時の混乱に拍車をかけています。

ここで始点を除外可能としたことは、そういう意味で、道筋が100パーセント明らかなも
のではありませんでした。ここで私が採用した RangeExtdクラスの定義は、おそらく、考え
られる唯一のものではないでしょう。とはいえ、個人的には満足のいくものに仕上がりま
したし、このレンジという枠内での論理的完全性をうまく達成できたと思います。

このクラスが少なからぬ人に有用なものであることを願ってここにリリースします。


== インストール

  gem install range_extd

により、ファイルが 2個、
  range_extd/range_extd.rb
  range_extd/infinity/infinity.rb
<tt>$LOAD_PATH</tt> の一カ所にインストールされるはずです。

あるいは、パッケージを以下から入手できます。
  http://rubygems.org/gems/range_extd

後は、Ruby のコード(又は irb)から
  require 'range_extd/range_extd'
とするだけです。もしくは、特に手でインストールした場合は、
  require 'range_extd'
とする必要があるかも知れません。もう一方のファイル
  range_extd/infinity/infinity.rb
は、自動的に読み込まれます。

お楽しみあれ!


== 単純な使用例

=== RangeExtd インスタンスを作成する方法

以下に幾つかの基本的な使用例を列挙します。

   r = RangeExtd(?a...?d, true)  # => a<...d
   r.exclude_begin?              # => true 
   r.to_a                        # => ["b", "c"]
   RangeExtd(1...2)            == (1...2)          # => true
   RangeExtd(1, 2, false, true)== (1...2)          # => true
   RangeExtd(1, 1, false, false)==(1..1)           # => true
   RangeExtd(1, 1, true, true) == RangeExtd::NONE  # => true
   RangeExtd(1, 1, false, true)  # => ArgumentError
   (RangeExtd::Infinity::NEGATIVE..RangeExtd::Infinity::POSITIVE) \
    == RangeExtd::EVERYTHING  # => true

インスタンスを作成するのには、二通りあります。

   RangeExtd(range, [exclude_begin=false, [exclude_end=false]])
   RangeExtd(obj_begin, obj_end, [exclude_begin=false, [exclude_end=false]])

後ろの二つのパラメーターが、それぞれ始点と終点とを除外する(true)、または含む
(false)を指示します。もし、その二つのパラメーターが最初のパラメーターのレンジ
(Range or RangeExtd) と矛盾する場合は、ここで与えた二つのパラメーターが優先され
ます。 <tt>RangeExtd.new()</tt> も上と同意味です。


=== 少し上級編

   (1..RangeExtd::Infinity::POSITIVE).each do |i|
     print i
     break if i >= 9
   end    # => self ( "123456789" => STDOUT )
   (nil..nil).valid?  # => false
   (1...1).valid?     # => false
   (1...1).null?      # => true
   RangeExtd.valid?(1...1)              # => false
   RangeExtd(1, 1, true, true).valid?   # => true
   RangeExtd(1, 1, true, true).empty?   # => true
   RangeExtd(?a, ?b, true, true).to_a?  # => []
   RangeExtd(?a, ?b, true, true).empty? # => true
   RangeExtd(?a, ?e, true, true).to_a?  # => ["b", "c", "d"]
   RangeExtd(?a, ?e, true, true).empty? # => false
   RangeExtd::NONE.is_none?             # => true
   RangeExtd::EVERYTHING.is_everything? # => true

組込Rangeに含まれる全てのメソッドが使用可能です。


== 詳説

ファイル range_extd.rb が読まれた段階で、次の二つのクラスが定義されます。

* RangeExtd
* RangeExtd::Infinity

加えて、Range クラスに数個のメソッドが追加また改訂されます。Rangeクラスに加えら
れる改変は、全て後方互換性を保っています。

=== RangeExtd::Infinity クラス

<tt>RangeExtd::Infinity</tt> クラスは、基本、定数二つのみを保持するものです。

* RangeExtd::Infinity::NEGATIVE
* RangeExtd::Infinity::POSITIVE

これらは、 <tt>Float::INFINITY</tt> を全ての Comparable なオブジェクトに一般化し
たものです。メソッド <tt><=></tt> と <tt>succ</tt> が定義されています。

これらは、他のオブジェクトと同様に普通に使用可能です。たとえば、
  <tt>("k"..RangeExtd::Infinity::POSITIVE)</tt>
とはいえ、他には何もメソッドを持っていないため、 Range型のクラスの中以外での使用
はおそらく意味がないでしょう。

なお、Numericのオブジェクトに対しては、原則として <tt>Float::INFINITY</tt> の方
を使って下さい。

ユーザー定義のどの Comparable なクラスに属するどのオブジェクトも、これら二定数と
可換的に比較可能です。その際、同クラスに置ける比較メソッドがマナー良く書かれてあ
る、という前提で。

さらに詳しくは、マニュアルを参照して下さい(YARD　または RDoc形式で書かれた文書が
コード内部に埋込まれていますし、それが RubyGemsのウェブサイトでも閲覧できます。


=== RangeExtd クラス

RangeExtd のインスタンスは、 Rangeと同じくイミュータブルです。だから、一度インス
タンスが生成されると、変化しません。

インスタンスの生成方法は上述の通りです(「使用例」の章)。レンジとして"valid"(後述)と見
なされないインスタンスを生成しようとすると、例外(<tt>ArgumentError</tt>)が発生し、
失敗します。

このクラスには、二つの定数が定義されています。

* RangeExtd::NONE
* RangeExtd::EVERYTHING

前者は、空レンジを表し、後者は全てを含むレンジ、すなわち正負両方向に開いたレンジを表します。

Rangeクラスの通常のメソッド全てに加え、以下が RangeExtd と Rangeクラス両方に加え
られています。詳細は、各メソッドのマニュアルを参照下さい(注: 幾つかのメソッドは
Rangeクラスのみで定義されていて、 RangeExtd はそれを継承しています)。

* <tt>exclude_begin?</tt> 
* <tt>valid?</tt> 
* <tt>empty?</tt> 
* <tt>null?</tt> 
* <tt>is_none?</tt> 
* <tt>is_everything?</tt> 

インスタンスメソッドの <tt>valid?</tt> に等価なクラスメソッドも一つあります。
* <tt>RangeExtd.valid?</tt> 

何がレンジとして有効 (<tt>#valid?</tt> => true) かの定義は以下です。

1. 始点と終点とが互いに Comparable であり、かつその比較結果に矛盾がないこと。
   この唯一の例外は <tt>RangeExtd::NONE</tt> で、これは valid です。
   たとえば、<tt>(nil..nil)</tt> は valid では「ありません」(参考までに、この例は
   Ruby 1.8 では例外を生じていました)。
2. 始点は終点と等しい(<tt>==</tt>)か小さくなければなりません。すなわし、
   <tt>(begin <=> end)</tt> は、-1 または 0 を返すこと。
3. もし始点と終点とが等しい時、すなわち <tt>(begin <=> end) == 0</tt>ならば、
   端を除外するかどうかのフラグは両端で一致していなければなりません。
   すなわち、もし始点が除外ならば、終点も除外されていなくてはならず、逆も真です。
   その一例として、 <tt>(1...1)</tt> は、"valid" では「ありません」。なぜならば
   組込レンジでは、始点を常に含むからです。

さらなる詳細は <tt>RangeExtd.valid?</tt> と <tt>Range#valid?</tt> のマニュアルを
参照して下さい。

何がレンジとして空(<tt>#empty?</tt> => true)かの定義は以下の通りです。

1. レンジは、valid であること: <tt>valid?</tt> => true
2. もしレンジの要素が離散的であれば、すなわち始点の要素がメソッド <tt>succ</tt>
   を持っていれば、レンジ内部に要素が一つも無いことが条件(当然、始点のフラグ
   は除外になっていなければなりません): <tt>to_a.empty?</tt> => true
3. もしレンジが連続的であれば、すなわち始点の要素がメソッド <tt>succ</tt> を持っ
   ていなければ、始点と終点とが等しく (<tt>(begin <=> end)</tt> => 0)、かつ両端
   のフラグが除外になっていること: <tt>(exclude_begin? && exclude_end?)</tt> => true.

なお、始点と終点とが等しい一方でその除外フラグが一致しない場合は、前節で述べたよ
うに "valid"ではありません。組込レンジは、始点除外フラグが常に偽(<tt>false</tt>)で
す。そのため、組込Rangeのオブジェクトで、<tt>empty?</tt> が真(<tt>true</tt>)にな
ることはありません。

さらなる詳細は <tt>Range#empty?</tt> のマニュアルを
参照して下さい。


最後、 <tt>Range#null?</tt> は、「<tt>empty?</tt> または "valid"でない」ことに等
価です。従って、 RangeExtd オブジェクトにとっては、<tt>null?</tt> は
<tt>empty?</tt> に等価です。

RangeExtd と別の RangeExtd または Rangeの比較 (<tt><=></tt>) においては、これら
の定義が考慮されます。そのうちの幾つかは、上の「使用例」の項に示されています。
さらなる詳細は <tt>Range#==</tt>、<tt>RangeExtd#==</tt> および
<tt>#eql?</tt> のマニュアルを参照して下さい。

なお、処理が Rangeオブジェクト内部で閉じている限り、その振舞いは標準 Rubyと同一
で、互換性を保っています。したがって、このライブラリを読込むことで既存のコードに
影響を与えることは原理的にないはずです。


== 既知のバグ

* <tt>hash()</tt> メソッドは、等しい RangeExtdオブジェに対して常に唯一で排他的な
  数値を返すことが保証されていません。ただし、現実的にそれが破られることは、まず
  ありません。

このライブラリは Ruby 1.8 およびそれ以前のバージョンでは動作しません。
Ruby 1.9.3 ではおそらく大丈夫でしょうが、私は試したことがありません。

パッケージに含まれている通り、網羅的なテストが実行されています。


== 未処理事項

特になし。


== 終わりに

RangeExtd内部に閉じた(Rangeでなく)挙動、たとえば RangeExtd同士の比較などは、
全てユーザーにとって自然なもののはずです(と期待します?)。少なくとも、RangeExtdに
よってレンジの論理構造が完結した今、これはよく定義されかつ自己矛盾が無いものと言
えましょう。ただ、端の無限に開いた、あるいは始点が除外されたレンジの挙動には、
一瞬ぎょっとするものが無くはないかも知れないことに注意して下さい。たとえば、
片端が小さい方向に無限に開いて離散的な要素を持つレンジに対してメソッド
<tt>member?(obj)</tt> を実行すると、 <tt>nil</tt>が返ります。これは、無限(小)に
は実質的な意味を持つ <tt>succ()</tt> メソッドが定義されていないためで、したがっ
て与えられた objがレンジの要素(member)かどうかを調べることが、一般論としては理論
的に不可能だからです。これはちょっと不思議に思うかも知れませんが、それはつまり定
命の私たちには無限という概念を計り知るのが容易でない、というだけの話でしょう!

一方、RangeExtd と Range との比較は、それ以上に驚くことがあるかも知れません。こ
れは、組込Rangeクラスで許容されているレンジの一部は、始点を除外することを認めた
枠組の中では、前述のように最早有効(valid)と見なされないからです。この枠組に慣れるに
したがって、それらが自然だと思えるようになればいいのですが。保証しますが、一旦こ
れに慣れてしまえば、論理的不完全さ極まる混沌とした世界、つまりは Rangeの現在の挙
動には二度と戻りたくなくなることでしょう!

お楽しみ下さい。


== その他

== 著作権他情報

著者::  Masa Sakano < imagine a_t sakano dot co dot uk >
利用許諾条項:: MIT.
保証:: 一切無し。
バージョン:: Semantic Versioning (2.0.0) http://semver.org/

